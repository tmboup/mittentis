CREATE TABLE mesures( 
    id INTEGER primary key autoincrement, 
    sensor_id INTEGER, data_type INTEGER, 
    value INTEGER, sent INTEGER default 0, 
    received INTEGER default 0, 
    unix_ts DATETIME DEFAULT CURRENT_TIMESTAMP
    
    )

var sql = "create table IF NOT EXISTS mesures( id INTEGER primary key autoincrement, 
                                                sensor_id INTEGER, data_type INTEGER, 
                                                value INTEGER, sent INTEGER default 0, 
                                                received INTEGER default 0, 
                                                unix_ts DATETIME DEFAULT CURRENT_TIMESTAMP
                                                )" ;




import os
import psycopg2
from psycopg2.extras import RealDictCursor

def get_latest_mesures():
    conn = psycopg2.connect(os.getenv("DB_LOCAL_URL"))
    cur = conn.cursor(cursor_factory=RealDictCursor)
    cur.execute(""" SELECT id, created_at, date, parameter, unit, updated_at, value, sensor_id FROM mesure WHERE sent IS FALSE OR sent IS NULL """)
    rows = cur.fetchall()
    
    # Optionnel : marquer comme envoy√©es ici ou plus tard apr√®s succ√®s
    
    conn.commit()
    cur.close()
    conn.close()
    return rows


####################################################################################################################################################################################
6`

* ex√©cute ton programme toutes les 4 heures,
* red√©marre automatiquement si le serveur red√©marre,
* g√®re les logs et les erreurs proprement.

La **meilleure pratique sous Ubuntu** n‚Äôest pas `cron` (trop limit√© en red√©marrage et monitoring), mais **systemd timers**. C‚Äôest moderne, fiable, relance apr√®s reboot et g√®re les logs avec `journalctl`.

---

## üöÄ √âtapes pour d√©ployer ton script avec systemd timer

### 1. Cr√©e un script ex√©cutable

Disons que ton code est dans `sync_data.py`.

üëâ Cr√©e un wrapper shell `/usr/local/bin/sync_data.sh` :

```bash
#!/bin/bash
set -euo pipefail

# Activer l‚Äôenvironnement Python si besoin
# source /home/tonuser/venv/bin/activate

# Ex√©cuter ton script et capturer les logs
python3 /home/tonuser/projet/sync_data.py >> /var/log/sync_data.log 2>&1
```

Puis rends-le ex√©cutable :

```bash
chmod +x /usr/local/bin/sync_data.sh
```

---

### 2. Cr√©e un service systemd

Fichier : `/etc/systemd/system/sync_data.service`

```ini
[Unit]
Description=Synchronisation des mesures locales vers la base distante
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/sync_data.sh
# Relance automatique si crash
Restart=on-failure
RestartSec=10
```

---

### 3. Cr√©e un timer systemd

Fichier : `/etc/systemd/system/sync_data.timer`

```ini
[Unit]
Description=Timer pour sync_data toutes les 4 heures

[Timer]
# Lancer toutes les 4 heures
OnCalendar=*:0/4
Persistent=true

[Install]
WantedBy=timers.target
```

> ‚úÖ `Persistent=true` ‚Üí si la machine √©tait √©teinte pendant une ex√©cution, systemd ex√©cute le job d√®s le red√©marrage pour rattraper. (Ce que `cron` ne fait pas).

---

### 4. Active et d√©marre

```bash
# Recharger systemd
sudo systemctl daemon-reload

# Activer le timer
sudo systemctl enable --now sync_data.timer

# V√©rifier
systemctl list-timers | grep sync_data
```

---

### 5. Logs et suivi

Voir les logs en temps r√©el :

```bash
journalctl -u sync_data.service -f
```

Ou lire les logs enregistr√©s :

```bash
cat /var/log/sync_data.log
```

---

## ‚úÖ Avantages de cette approche

* **Tol√©rance aux fautes** : si le script crash ‚Üí relance.
* **Persistance** : si la machine red√©marre ‚Üí le job continue automatiquement.
* **Fiabilit√©** : `systemd` est plus robuste que `cron`.
* **Debug facile** : logs centralis√©s (`journalctl`).

---

üëâ Veux-tu que je t‚Äô√©crive aussi une **version "safe" de ton `sync_data.py`** (avec gestion des exceptions, logs robustes, retry si le serveur distant est down), pour que le d√©ploiement soit vraiment **premium++** ?




CREATE TABLE IF NOT EXISTS mesures (
    id SERIAL PRIMARY KEY,
    sensor_id INTEGER,
    data_type INTEGER,
    value INTEGER,
    sent INTEGER DEFAULT 0,
    received INTEGER DEFAULT 0,
    unix_ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
